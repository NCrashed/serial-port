// Copyright 2013 Gushcha Anton
/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
// Written in D programming language
/**
*   Module providing instruments to work with serial port on Windows and Posix
*   OS. SerialPort class can enumerate available serial ports (works robust only 
*   on Windows), check available baud rates. 
*   
*   Example:
*   --------
*   auto com = new SerialPort("COM1"); // ttyS0 on GNU/Linux, for instance
*   string test = "Hello, World!";
*   com.write(test.ptr);
*   
*   ubyte[13] buff;
*   com.read(buff);
*   writeln(cast(string)buff);
*   --------
*
*   Note: Some points were extracted from Tango D2 library.
*   TODO: Serial port tweaking, asynchronous i/o.
*/
module serial.device;

import std.conv;
import std.string;

version(Posix)
{
    import core.sys.posix.unistd;
    import core.sys.posix.termios;
    import core.sys.posix.fcntl;
    import std.algorithm;
    import std.file;

    enum B57600 = 57600;
    enum B115200 = 115200;
}
version(Windows)
{
    import core.sys.windows.windows;
    import std.bitmanip;
}

/**
*   Represents allowed baud rate speeds for serial port.
*/
enum BaudRate : uint
{
    BR_110    = 110,
    BR_300    = 300,
    BR_600    = 600,
    BR_1200   = 1200,
    BR_2400   = 2400,
    BR_4800   = 4800,
    BR_9600   = 9600,
    BR_19200  = 19200,
    BR_38400  = 38400,
    BR_57600  = 57600,
    BR_115200 = 115200,
    BR_UNKNOWN // refers to unknown baud rate
}

/**
*   Thrown when trying to setup serial port with
*   unsupported baud rate by current OS.
*/
class SpeedUnsupportedException : Exception
{
    BaudRate speed;

    this(BaudRate spd)
    {
        speed = spd;
        super(text("Speed ", spd, " is unsupported!"));
    }
}

/**
*   Thrown when setting up new serial port parameters has failed.
*/
class InvalidParametersException : Exception 
{
    string port;

    this(string port)
    {
        this.port = port;
        super("One of serial port "~ port ~ " parameters is invalid!");
    }
}

/**
*   Thrown when tried to open invalid serial port file.
*/
class InvalidDeviceException : Exception
{
    string port;

    this(string port)
    {
        this.port = port;
        super(text("Failed to open serial port with name ", port, "!"));
    }
}

/**
*   Thrown when trying to accept closed device.
*/
class DeviceClosedException : Exception 
{
    this()
    {
        super("Tried to access closed device!");
    }
}

/**
*   Thrown when reading from serial port is failed.
*/
class DeviceReadException : Exception 
{
    string port;

    this(string port)
    {
        this.port = port;
        super("Failed to read from serial port with name " ~ port);
    }
}

/**
*   Thrown when writing to serial port is failed.
*/
class DeviceWriteException : Exception 
{
    string port;

    this(string port)
    {
        this.port = port;
        super("Failed to write to serial port with name " ~ port);
    }
}

version(Windows)
{
    enum NOPARITY    = 0x0;
    enum EVENPARITY  = 0x2;
    enum MARKPARITY  = 0x3;
    enum ODDPARITY   = 0x1;
    enum SPACEPARITY = 0x4;

    enum ONESTOPBIT   = 0x0;
    enum ONE5STOPBITS = 0x1;
    enum TWOSTOPBITS  = 0x2;

    struct DCB 
    {
        DWORD DCBlength;
        DWORD BaudRate;

        mixin(bitfields!(
        DWORD, "fBinary",           1,
        DWORD, "fParity",           1,
        DWORD, "fOutxCtsFlow",      1,
        DWORD, "fOutxDsrFlow",      1,
        DWORD, "fDtrControl",       2,
        DWORD, "fDsrSensitivity",   1,
        DWORD, "fTXContinueOnXoff", 1,
        DWORD, "fOutX",             1,
        DWORD, "fInX",              1,
        DWORD, "fErrorChar",        1,
        DWORD, "fNull",             1,
        DWORD, "fRtsControl",       2,
        DWORD, "fAbortOnError",     1,
        DWORD, "fDummy2",           17));
        
        WORD  wReserved;
        WORD  XonLim;
        WORD  XoffLim;
        BYTE  ByteSize;
        BYTE  Parity;
        BYTE  StopBits;
        ubyte  XonChar;
        ubyte  XoffChar;
        ubyte  ErrorChar;
        ubyte  EofChar;
        ubyte  EvtChar;
        WORD  wReserved1;
    }

    extern(Windows) 
    {
        bool GetCommState(HANDLE hFile, DCB* lpDCB);
        bool SetCommState(HANDLE hFile, DCB* lpDCB);
    }
}

/**
*   Main class encapsulating platform dependent files handles and
*   algorithms to work with serial port.
*
*   You can open serial port only once, after calling close any 
*   nonstatic method will throw DeviceClosedException.
*
*   Note: Serial port enumerating is robust only on Windows, due
*   other platform doesn't strictly bound serial port names.
*/
class SerialPort
{
    /**
    *   Creates new serial port instance.
    *
    *   Params:
    *   port =  Port name. On Posix, it should be reffer to device file
    *           like /dev/ttyS<N>. If port string doesn't begin with '/',
    *           "/dev/" is automatically appended to the begining of input.
    *           On Windows, port name should be like COM<N> or any other.
    *
    *   Throws: InvalidParametersException, InvalidDeviceException
    *   
    */
    this(string port)
    {
        setup(port);
    }

    ~this()
    {
        close();
    }

    /**
    *   Converts serial port to it port name. 
    *   Example: "ttyS0", "ttyS1", "COM1", "CNDA1".
    */
    override string toString()
    {
        return port;
    }

    /**
    *   Set the baud rate for this serial port. Speed values are usually 
    *   restricted to be 1200 * i ^ 2.
    *
    *   Note: that for Posix, the specification only mandates speeds up
    *   to 38400, excluding speeds such as 7200, 14400 and 28800.
    *   Most Posix systems have chosen to support at least higher speeds
    *   though.
    *
    *   Throws: SpeedUnsupportedException if speed is unsupported by current system.
    */
    SerialPort speed(BaudRate speed) @property
    {
        if (closed) throw new DeviceClosedException();

        version(Posix)
        {
            speed_t baud = convertPosixSpeed(speed);
            
            termios options;
            tcgetattr(handle, &options);
            cfsetospeed(&options, baud);
            tcsetattr(handle, TCSANOW, &options);
        }
        version(Windows)
        {
            DCB config;
            GetCommState(handle, &config);
            config.BaudRate = cast(DWORD)speed;
            if(!SetCommState(handle, &config))
            {
                throw new SpeedUnsupportedException(speed);
            }
        }

        return this;
    }

    /**
    *   Returns current port speed. Can return BR_UNKNONW baud rate
    *   if speed was changed not by speed property or wreid errors are occured.
    */
    BaudRate speed() @property
    {
        if (closed) throw new DeviceClosedException();

        version(Posix)
        {
            speed_t baud;
            
            termios options;
            tcgetattr(handle, &options);
            cfgetospeed(&options, &baud);
            return getBaudSpeed(cast(uint)baud);
        }
        version(Windows)
        {
            DCB config;
            GetCommState(handle, &config);
            return getBaudSpeed(cast(uint)config.BaudRate);
        }
    }

    /**
    *   Iterates over all bauds rate and tries to setup port with it.
    *   Returns: array of successfully setuped baud rates for current 
    *   serial port.
    */
    BaudRate[] getBaudRates()
    {
        if (closed) throw new DeviceClosedException();

        BaudRate currSpeed = speed;
        BaudRate[] ret; 
        foreach(baud; __traits(allMembers, BaudRate))
        {
            if(baud != "BR_UNKNOWN")
            {
                auto baudRate = mixin("BaudRate."~baud);
                scope(success) ret ~= baudRate;
                scope(failure) {}

                speed = baudRate;
            }
        }

        speed = currSpeed;
        return ret;
    }

    /**
    *   Tries to enumerate all serial ports. While this usually works on
    *   Windows, it's more problematic on other OS. Posix provides no way
    *   to list serial ports, and the only option is searching through
    *   "/dev".
    *
    *   Because there's no naming standard for the device files, this method
    *   must be ported for each OS. This method is also unreliable because
    *   the user could have created invalid device files, or deleted them.
    *
    *   Returns:
    *   A string array of all the serial ports that could be found, in
    *   alphabetical order. Every string is formatted as a valid argument
    *   to the constructor, but the port may not be accessible.
    */
    static string[] ports()
    {
        string[] ports;
        version(Windows)
        {
            // try to open COM1..255
            immutable pre = `\\.\COM`;
            for(int i = 1; i <= 255; ++i)
            {
                HANDLE port = CreateFileA(text(pre, i).toStringz, GENERIC_READ | GENERIC_WRITE, 0, null, OPEN_EXISTING, 0, null);
                if(port != INVALID_HANDLE_VALUE)
                {
                    ports ~= text("COM", i);
                    CloseHandle(port);
                }
            }
        }
        version(Posix)
        {
            bool comFilter(DirEntry entry)
            {
                bool isInRange(T, U)(T val, U lower, U upper)
                {
                    auto cval = val.to!U;
                    return cval >= lower && cval <= upper;
                }

                version(linux)
                {
                    return (entry.name.find("ttyUSB") == 0
                           || entry.name.find("ttyS") == 0)
                           && entry.name[$-1].isInRange(0, 9);
                }
                version(darwin)
                {
                    return entry.name.find("cu") == 0;
                }
                version(FreeBSD)
                {
                    return (entry.name.find("cuaa") == 0
                           || entry.name.find("cuad") == 0)
                           && entry.name[$-1].isInRange(0, 9);
                }
                version(openbsd)
                {
                    return entry.name.find("tty") == 0
                           && entry.name[$-1].isInRange(0, 9);
                }
                version(solaris)
                {
                    return entry.name.find("tty") == 0
                           && entry.name[$-1].isInRange('a', 'z');
                } else
                {
                    return false;
                }
            }

            auto portFiles = filter!(&comFilter)(dirEntries("/dev",SpanMode.width));
            foreach(entry; portFiles)
            {
                ports ~= entry.name;
            }
        }
        return ports;
    }

    /**
    *   Closing underlying serial port. You shouldn't use port after
    *   it closing.
    */
    void close()
    {
        version(Windows)
        {
            if(handle !is null)
            {
                CloseHandle(handle);
                handle = null;
            }
        }
        version(Posix)
        {
            if(handle != -1)
            {
                close(handle);
                handle = -1;
            }
        }
    }

    /**
    *   Returns true if serial port was closed.
    */
    bool closed() @property
    {
        version(Windows)
            return handle is null;
        version(Posix)
            return handle == -1;
    }

    /**
    *   Writes down array of bytes to serial port.
    */
    void write(const(void[]) arr)
    {
        if (closed) throw new DeviceClosedException();

        version(Windows)
        {
            size_t totalWritten;
            while(totalWritten < arr.length)
            {
                uint written;
                if(!WriteFile(handle, arr[totalWritten..$].ptr, 
                    cast(uint)(arr.length-totalWritten), &written, null))
                        throw new DeviceWriteException(port);
                totalWritten += written;
            }
        }
        version(Posix)
        {
            size_t totalWritten;
            while(totalWritten < arr.length)
            {
                ssize_t result = write(handle, arr[totalWritten..$].ptr, arr.length - totalWritten);
                if(result < 0)
                    throw new DeviceWriteException(port);
                totalWritten += cast(size_t)result;
            }
        }
    } 

    /**
    *   Fills up provided array with bytes from com port.
    *   Returns: actual number of readed bytes.
    *   Throws: DeviceReadException
    */
    size_t read(void[] arr)
    {
        if (closed) throw new DeviceClosedException();

        version(Windows)
        {
            uint readed;
            if(!ReadFile(handle, arr.ptr, cast(uint)arr.length, &readed, null))
                throw new DeviceReadException(port);
            return cast(size_t)readed;
        }
        version(Posix)
        {
            ssize_t result = read(handle, arr.ptr, arr.length);
            if(result < 0)
            {
                throw new DeviceReadException(port);
            }
            return cast(size_t)result;
        }
    }

    protected
    {
        version(Windows)
        {
            private void setup(string port)
            {
                this.port = port;
                handle = CreateFileA((`\\.\` ~ port).toStringz, GENERIC_READ | GENERIC_WRITE, 0, null, OPEN_EXISTING, 0, null);
                if(handle is INVALID_HANDLE_VALUE)
                {
                    throw new InvalidDeviceException(port);
                }

                DCB config;
                GetCommState(handle, &config);
                config.BaudRate = 9600;
                config.ByteSize = 8;
                config.Parity = NOPARITY;
                config.StopBits = ONESTOPBIT;
                config.fBinary = 1;
                config.fParity = 1;

                if(!SetCommState(handle, &config))
                {
                    throw new InvalidParametersException(port);
                }
            }
        }

        version(Posix)
        {
            private static __gshared speed_t[BaudRate] posixBRTable;
            shared static this()
            {
                posixBRTable = [
                    BaudRate.BR_110 : B110,
                    BaudRate.BR_300 : B300,
                    BaudRate.BR_600 : B600,
                    BaudRate.BR_1200 : B1200,
                    BaudRate.BR_2400 : B2400,
                    BaudRate.BR_4800 : B4800,
                    BaudRate.BR_9600 : B9600,
                    BaudRate.BR_38400 : B38400,
                    BaudRate.BR_57600 : B57600,
                    BaudRate.BR_115200 : B115200
                ];
            }

            speed_t convertPosixSpeed(BaudRate baud)
            {
                if(baud in posixBRTable) return posixBRTable[baud];
                throw new SpeedUnsupportedException(baud);
            }

            void create (string file)
            {
                if(file.length == 0) throw new InvalidDeviceException(file);
                if(file[0] != '/') file = "/dev/" ~ file;

                if(file.length > 5 && file[0..5] == "/dev/")
                    port = file[5..$];
                else
                    port = file;

                handle = open(file.toStringz(), O_RDWR | O_NOCTTY | O_NONBLOCK);
                if(handle == -1) 
                {
                    throw new InvalidDeviceException(file);
                }
                if(posix.fcntl(handle, F_SETFL, 0) == -1) 
                {   // disable O_NONBLOCK
                    throw new InvalidDeviceException(file);
                }

                termios options;
                if(tcgetattr(handle, &options) == -1) 
                {
                    throw new InvalidDeviceException(file);
                }
                cfsetispeed(&options, B0); // same as output baud rate
                cfsetospeed(&options, B9600);
                makeRaw(&options); // disable echo and special characters
                tcsetattr(handle, TCSANOW, &options);
            }

            void makeRaw (termios *options)
            {
                options.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP
                        | INLCR | IGNCR | ICRNL | IXON);
                options.c_oflag &= ~OPOST;
                options.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
                options.c_cflag &= ~(CSIZE | PARENB);
                options.c_cflag |= CS8;
            }
        }

        private static __gshared BaudRate[uint] baudRatetoUint;
        shared static this() 
        {
            baudRatetoUint = [
                110 : BaudRate.BR_110,
                300 : BaudRate.BR_300,
                600 : BaudRate.BR_600,
                1200 : BaudRate.BR_1200,
                2400 : BaudRate.BR_2400,
                4800 : BaudRate.BR_4800,
                9600 : BaudRate.BR_9600,
                38400 : BaudRate.BR_38400,
                57600 : BaudRate.BR_57600,
                115200 : BaudRate.BR_115200,
            ];
        }

        BaudRate getBaudSpeed(uint value)
        {
            if(value in baudRatetoUint) return baudRatetoUint[value];
            return BaudRate.BR_UNKNOWN;
        }
    }

    private
    {
        /// Port name
        string port;
        /// Port handle
        version(Posix)
            int handle = -1;
        version(Windows)
            HANDLE handle = null;
   }   
}